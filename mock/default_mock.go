// Code generated by MockGen. DO NOT EDIT.
// Source: interface.go

package mock

import (
	gocb "github.com/couchbase/gocb"
	conf "github.com/deadcheat/gocbadaptor/conf"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockCouchBaseAdaptor is a mock of CouchBaseAdaptor interface
type MockCouchBaseAdaptor struct {
	ctrl     *gomock.Controller
	recorder *MockCouchBaseAdaptorMockRecorder
}

// MockCouchBaseAdaptorMockRecorder is the mock recorder for MockCouchBaseAdaptor
type MockCouchBaseAdaptorMockRecorder struct {
	mock *MockCouchBaseAdaptor
}

// NewMockCouchBaseAdaptor creates a new mock instance
func NewMockCouchBaseAdaptor(ctrl *gomock.Controller) *MockCouchBaseAdaptor {
	mock := &MockCouchBaseAdaptor{ctrl: ctrl}
	mock.recorder = &MockCouchBaseAdaptorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCouchBaseAdaptor) EXPECT() *MockCouchBaseAdaptorMockRecorder {
	return m.recorder
}

// Bucket mocks base method
func (m *MockCouchBaseAdaptor) Bucket() *gocb.Bucket {
	ret := m.ctrl.Call(m, "Bucket")
	ret0, _ := ret[0].(*gocb.Bucket)
	return ret0
}

// Bucket indicates an expected call of Bucket
func (mr *MockCouchBaseAdaptorMockRecorder) Bucket() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Bucket", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).Bucket))
}

// Env mocks base method
func (m *MockCouchBaseAdaptor) Env() *conf.Env {
	ret := m.ctrl.Call(m, "Env")
	ret0, _ := ret[0].(*conf.Env)
	return ret0
}

// Env indicates an expected call of Env
func (mr *MockCouchBaseAdaptorMockRecorder) Env() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Env", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).Env))
}

// ExpiresIn mocks base method
func (m *MockCouchBaseAdaptor) ExpiresIn(sec uint32) {
	m.ctrl.Call(m, "ExpiresIn", sec)
}

// ExpiresIn indicates an expected call of ExpiresIn
func (mr *MockCouchBaseAdaptorMockRecorder) ExpiresIn(sec interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExpiresIn", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).ExpiresIn), sec)
}

// Get mocks base method
func (m *MockCouchBaseAdaptor) Get(key string) (gocb.Cas, []byte, error) {
	ret := m.ctrl.Call(m, "Get", key)
	ret0, _ := ret[0].(gocb.Cas)
	ret1, _ := ret[1].([]byte)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Get indicates an expected call of Get
func (mr *MockCouchBaseAdaptorMockRecorder) Get(key interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).Get), key)
}

// Insert mocks base method
func (m *MockCouchBaseAdaptor) Insert(key string, data []byte) (gocb.Cas, error) {
	ret := m.ctrl.Call(m, "Insert", key, data)
	ret0, _ := ret[0].(gocb.Cas)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Insert indicates an expected call of Insert
func (mr *MockCouchBaseAdaptorMockRecorder) Insert(key, data interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Insert", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).Insert), key, data)
}

// N1qlQuery mocks base method
func (m *MockCouchBaseAdaptor) N1qlQuery(q string, params interface{}) (gocb.QueryResults, error) {
	ret := m.ctrl.Call(m, "N1qlQuery", q, params)
	ret0, _ := ret[0].(gocb.QueryResults)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// N1qlQuery indicates an expected call of N1qlQuery
func (mr *MockCouchBaseAdaptorMockRecorder) N1qlQuery(q, params interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "N1qlQuery", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).N1qlQuery), q, params)
}

// N1qlQueryWithMode mocks base method
func (m *MockCouchBaseAdaptor) N1qlQueryWithMode(mode *gocb.ConsistencyMode, q string, params interface{}) (gocb.QueryResults, error) {
	ret := m.ctrl.Call(m, "N1qlQueryWithMode", mode, q, params)
	ret0, _ := ret[0].(gocb.QueryResults)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// N1qlQueryWithMode indicates an expected call of N1qlQueryWithMode
func (mr *MockCouchBaseAdaptorMockRecorder) N1qlQueryWithMode(mode, q, params interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "N1qlQueryWithMode", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).N1qlQueryWithMode), mode, q, params)
}

// Open mocks base method
func (m *MockCouchBaseAdaptor) Open(connection, bucket, password string, expiry uint32) error {
	ret := m.ctrl.Call(m, "Open", connection, bucket, password, expiry)
	ret0, _ := ret[0].(error)
	return ret0
}

// Open indicates an expected call of Open
func (mr *MockCouchBaseAdaptorMockRecorder) Open(connection, bucket, password, expiry interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Open", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).Open), connection, bucket, password, expiry)
}

// OpenWithConfig mocks base method
func (m *MockCouchBaseAdaptor) OpenWithConfig(env *conf.Env) error {
	ret := m.ctrl.Call(m, "OpenWithConfig", env)
	ret0, _ := ret[0].(error)
	return ret0
}

// OpenWithConfig indicates an expected call of OpenWithConfig
func (mr *MockCouchBaseAdaptorMockRecorder) OpenWithConfig(env interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OpenWithConfig", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).OpenWithConfig), env)
}

// Upsert mocks base method
func (m *MockCouchBaseAdaptor) Upsert(key string, data []byte) (gocb.Cas, error) {
	ret := m.ctrl.Call(m, "Upsert", key, data)
	ret0, _ := ret[0].(gocb.Cas)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Upsert indicates an expected call of Upsert
func (mr *MockCouchBaseAdaptorMockRecorder) Upsert(key, data interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Upsert", reflect.TypeOf((*MockCouchBaseAdaptor)(nil).Upsert), key, data)
}

// MockLoggerable is a mock of Loggerable interface
type MockLoggerable struct {
	ctrl     *gomock.Controller
	recorder *MockLoggerableMockRecorder
}

// MockLoggerableMockRecorder is the mock recorder for MockLoggerable
type MockLoggerableMockRecorder struct {
	mock *MockLoggerable
}

// NewMockLoggerable creates a new mock instance
func NewMockLoggerable(ctrl *gomock.Controller) *MockLoggerable {
	mock := &MockLoggerable{ctrl: ctrl}
	mock.recorder = &MockLoggerableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockLoggerable) EXPECT() *MockLoggerableMockRecorder {
	return m.recorder
}

// Log mocks base method
func (m *MockLoggerable) Log(arg0 ...interface{}) {
	varargs := []interface{}{}
	for _, a := range arg0 {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Log", varargs...)
}

// Log indicates an expected call of Log
func (mr *MockLoggerableMockRecorder) Log(arg0 ...interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Log", reflect.TypeOf((*MockLoggerable)(nil).Log), arg0...)
}

// Logf mocks base method
func (m *MockLoggerable) Logf(format string, v ...interface{}) {
	varargs := []interface{}{format}
	for _, a := range v {
		varargs = append(varargs, a)
	}
	m.ctrl.Call(m, "Logf", varargs...)
}

// Logf indicates an expected call of Logf
func (mr *MockLoggerableMockRecorder) Logf(format interface{}, v ...interface{}) *gomock.Call {
	varargs := append([]interface{}{format}, v...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Logf", reflect.TypeOf((*MockLoggerable)(nil).Logf), varargs...)
}
